/**
 * 
 */
package com.deedm.legacy.algebra;

import java.util.List;

import com.deedm.legacy.setrelfun.PartialOrder;
import com.deedm.legacy.setrelfun.Set;

/**
 * @author user
 *
 */
public class testAlgebra {

	public static void testGroupUnitModulo() {
		int n = 13;
		GroupUnitModulo UGroup = new GroupUnitModulo(n);
		Integer[] elements = UGroup.getElements();
		
		System.out.println("U" + n + " = {" + GroupUnitModulo.integerArrayToString(elements) + "}");
		System.out.println("The power of elements:");
		for (int i = 0; i < elements.length; i++) {
			StringBuffer message = new StringBuffer();
			int inverse = UGroup.getInverse(elements[i]);
			message.append("\t" + elements[i] + "^{-1}=" + inverse + "\t");
			for (int j = 1; j <= elements.length; j++) {
				int power = UGroup.power(elements[i], j);
				message.append(elements[i] + "^" + j + "=" + power + "\t");
				if (power == UGroup.getIdentity()) break;
			}
			System.out.println(message.toString());
		}
		
		if (UGroup.isCycleGroup()) {
			int[] generator = GroupUnitModulo.integerListToArray(UGroup.getGenerator());
			System.out.println("U" + n + " is a cycle group, generator : " + GroupUnitModulo.integerArrayToString(generator));
		} else System.out.println("U" + n + " is not a cycle group!");
		
		for (int i = 0; i < elements.length; i++) {
			int order = UGroup.getOrder(elements[i]);
			System.out.println("\tThe order of the element " + elements[i] + " is " + order);
		}
		List<List<Integer>> allSubGroups = UGroup.getAllGeneratedSubgroup();
		for (List<Integer> subgroup : allSubGroups) {
			System.out.println("Sub group: {" + GroupUnitModulo.integerListToString(subgroup) + "}");
			List<int[]> allCosets = UGroup.getAllCoset(subgroup);
			System.out.println("\tIts coset include: ");
			for (int[] coset : allCosets) System.out.println("\t\t{" + GroupUnitModulo.integerArrayToString(coset) + "}");
		}
	}
	
	public static void testGroupPermutation() {
		int n = 4;
		GroupPermutation SGroup = new GroupPermutation(n);
		GroupPermutation.Bijection[] elements = SGroup.getElements();
		
		System.out.println("S" + n + " = {" + GroupPermutation.FunctionArrayToString(elements) + "}");
		for (int i = 0; i < elements.length; i++) {
			System.out.println("\t" + elements[i]);
		}
		System.out.println();
		System.out.println("The power of elements:");
		for (int i = 0; i < elements.length; i++) {
			StringBuffer message = new StringBuffer();
			GroupPermutation.Bijection inverse = SGroup.getInverse(elements[i]);
			message.append("\t" + elements[i].getName() + "^{-1}=" + inverse.getName() + "\t");
			for (int j = 1; j <= elements.length; j++) {
				GroupPermutation.Bijection power = SGroup.power(elements[i], j);
				message.append(elements[i].getName() + "^" + j + "=" + power.getName() + "\t");
				if (power == SGroup.getIdentity()) break;
			}
			System.out.println(message.toString());
		}
		
		if (SGroup.isCycleGroup()) {
			GroupPermutation.Bijection[] generator = GroupPermutation.FunctionListToArray(SGroup.getGenerator());
			System.out.println("S" + n + " is a cycle group, generator : " + GroupPermutation.FunctionArrayToString(generator));
		} else System.out.println("S" + n + " is not a cycle group!");
		
		for (int i = 0; i < elements.length; i++) {
			int order = SGroup.getOrder(elements[i]);
			System.out.println("\tThe order of the element " + elements[i].getName() + " is " + order);
		}
		List<List<GroupPermutation.Bijection>> allSubGroups = SGroup.getAllGeneratedSubgroup();
		for (List<GroupPermutation.Bijection> subgroup : allSubGroups) {
			System.out.println("Sub group: {" + GroupPermutation.FunctionListToString(subgroup) + "}");
			List<GroupPermutation.Coset> allCosets = SGroup.getAllLeftCoset(subgroup);
			System.out.println("\tIts left coset include: ");
			for (GroupPermutation.Coset coset : allCosets) System.out.println("\t\t" + coset);
			allCosets = SGroup.getAllRightCoset(subgroup);
			System.out.println("\tIts right coset include: ");
			for (GroupPermutation.Coset coset : allCosets) System.out.println("\t\t" + coset);
		}
	}

	
	public static void testSubgroup() {
		int n = 60;
		GroupUnitModulo UGroup = new GroupUnitModulo(n);
		Integer[] elements = UGroup.getElements();
		
		System.out.println("U" + n + " = {" + GroupUnitModulo.integerArrayToString(elements) + "}");
		
		System.out.println("All subgroup generated by a single element!");
		List<List<Integer>> allGeneratedSubgroups = UGroup.getAllGeneratedSubgroup();
		for (List<Integer> subgroup : allGeneratedSubgroups) {
			System.out.println("Sub group: {" + GroupUnitModulo.integerListToString(subgroup) + "}");

			Integer[] array = new Integer[subgroup.size()];
			for (int i = 0; i < subgroup.size(); i++) array[i] = subgroup.get(i);
			List<Integer> generatorList = UGroup.getGenerator(array);
			if (generatorList.size() > 0) {
				System.out.println("\tIt has generator: " + GroupUnitModulo.integerListToString(generatorList));
			} else System.out.println("\tIt is not a generated subgroup!");
		}
		System.out.println();
		
		System.out.println("All subgroup.....");
		List<List<Integer>> allSubgroups = UGroup.getAllSubgroup();
		for (List<Integer> subgroup : allSubgroups) {
			System.out.println("Sub group: {" + GroupUnitModulo.integerListToString(subgroup) + "}");

			Integer[] array = new Integer[subgroup.size()];
			for (int i = 0; i < subgroup.size(); i++) array[i] = subgroup.get(i);
			List<Integer> generatorList = UGroup.getGenerator(array);
			if (generatorList.size() > 0) {
				System.out.println("\tIt has generator: " + GroupUnitModulo.integerListToString(generatorList));
			} else System.out.println("\tIt is not a generated subgroup!");
		}
	}

	public static void testPermutationSubgroup() {
		int num = 4;
		GroupPermutation SGroup = new GroupPermutation(num);
		GroupPermutation.Bijection[] funElements = SGroup.getElements();
		
		System.out.println("S" + num + " = {" + GroupPermutation.FunctionArrayToString(funElements) + "}");
		for (int i = 0; i < funElements.length; i++) {
			System.out.println("\t" + funElements[i].toFullString());
		}
		System.out.println();
		
		List<List<GroupPermutation.Bijection>> allGeneratedFunSubgroups = SGroup.getAllGeneratedSubgroup();
		System.out.println("All generated subgroup.....");
		for (List<GroupPermutation.Bijection> subgroup : allGeneratedFunSubgroups) {
			System.out.println("Sub group: {" + GroupPermutation.FunctionListToString(subgroup) + "}");

			GroupPermutation.Bijection[] array = new GroupPermutation.Bijection[subgroup.size()];
			for (int i = 0; i < subgroup.size(); i++) array[i] = subgroup.get(i);
			List<GroupPermutation.Bijection> generatorList = SGroup.getGenerator(array);
			if (generatorList.size() > 0) {
				System.out.println("\tIt has generator: " + GroupPermutation.FunctionListToString(generatorList));
			} else System.out.println("\tIt is not a generated subgroup!");
		}
		System.out.println();
		
		List<List<GroupPermutation.Bijection>> allFunSubgroups = SGroup.getAllSubgroup();
		System.out.println("All subgroup.....");
		for (List<GroupPermutation.Bijection> subgroup : allFunSubgroups) {
			System.out.println("Sub group: {" + GroupPermutation.FunctionListToString(subgroup) + "}");

			GroupPermutation.Bijection[] array = new GroupPermutation.Bijection[subgroup.size()];
			for (int i = 0; i < subgroup.size(); i++) array[i] = subgroup.get(i);
			List<GroupPermutation.Bijection> generatorList = SGroup.getGenerator(array);
			if (generatorList.size() > 0) {
				System.out.println("\tIt has generator: " + GroupPermutation.FunctionListToString(generatorList));
			} else System.out.println("\tIt is not a generated subgroup!");
		}
	}
	
	public static void testPermutationNormalSubgroup() {
		int num = 4;
		GroupPermutation SGroup = new GroupPermutation(num);
		GroupPermutation.Bijection[] funElements = SGroup.getElements();
		
		System.out.println("S" + num + " = {" + GroupPermutation.FunctionArrayToString(funElements) + "}");
		for (int i = 0; i < funElements.length; i++) {
			System.out.println("\t" + funElements[i].toFullString());
		}
		System.out.println();
		
		List<List<GroupPermutation.Bijection>> allFunSubgroups = SGroup.getAllSubgroup();
		System.out.println("All subgroup.....");
		for (List<GroupPermutation.Bijection> subgroup : allFunSubgroups) {
			System.out.println("Sub group: {" + GroupPermutation.FunctionListToString(subgroup) + "}");

			List<GroupPermutation.Coset> allCosets = SGroup.getAllLeftCoset(subgroup);
			System.out.println("\tIts left coset include: ");
			StringBuffer message = new StringBuffer();
			message.append("\t\t");
			for (GroupPermutation.Coset coset : allCosets) message.append(coset + "  ");
			System.out.println(message.toString());
			
			allCosets = SGroup.getAllRightCoset(subgroup);
			System.out.println("\tIts right coset include: ");
			message = new StringBuffer();
			message.append("\t\t");
			for (GroupPermutation.Coset coset : allCosets) message.append(coset + "  ");
			System.out.println(message.toString());
			
			if (SGroup.isNormalSubgroup(subgroup)) {
				System.out.println("The subgroup is a nomral group, the quotient group's operation table is as follows:");
				GroupPermutation.QuotientGroup quotient = SGroup.getQuotientGroup(subgroup);
				quotient.printlnOperationTable();
				System.out.println();
			} else System.out.println("The subgroup is NOT a normal group!");
		}
	}
	
	public static void testLattice() {
		int n = 1001;
		PartialOrder relation = PartialOrder.createFactorDivisionOrder(n);
		Lattice lattice = Lattice.createLatticeFromPoset(relation);
		if (lattice.isBooleanAlgebra()) {
			System.out.println("The lattice F(" + n + ") is a boolean algebra!");
			char greastElement = lattice.getGreatestElement();
			System.out.println("\tThe greatest element is " + Set.getElementLabel(greastElement, true));
			char leastElement = lattice.getLeastElement();
			System.out.println("\tThe least element is " + Set.getElementLabel(leastElement, true));
			Set base = lattice.getFromSet();
			for (int i = 0; i < base.length(); i++) {
				char element = base.get(i);
				char complement = lattice.getComplement(element);
				System.out.println("\tThe complement of element " + Set.getElementLabel(element, true) + " is " + Set.getElementLabel(complement, true));
			}
		} else {
			System.out.println("The lattice F(" + n + ") is NOT a boolean algebra!");
			if (lattice.hasGreatestElement()) {
				char greastElement = lattice.getGreatestElement();
				System.out.println("\tThe greatest element is " + Set.getElementLabel(greastElement, true));
			} else System.out.println("\tThere is no greatest element!");
			if (lattice.hasLeastElement()) {
				char leastElement = lattice.getLeastElement();
				System.out.println("\tThe least element is " + Set.getElementLabel(leastElement, true));
			} else System.out.println("\tThere is no greatest element!");
			Set base = lattice.getFromSet();
			char[] complements = new char[base.length()];
			for (int i = 0; i < base.length(); i++) {
				char element = base.get(i);
				int counter = lattice.getComplement(element, complements);
				if (counter > 0) {
					System.out.println("\tThe complement of element " + Set.getElementLabel(element, true) + " includes " + charArrayToString(complements, counter));
				} else System.out.println("\tThe complement of element " + Set.getElementLabel(element, true) + " has NOT complement!");
			}
		}
	}
	
	public static String charArrayToString(char[] charArray, int number) {
		StringBuffer buffer = new StringBuffer();
		for (int i = 0; i < number; i++) buffer.append(Set.getElementLabel(charArray[i], true) + " ");
		return buffer.toString();
	}
	
	public static void testPermutation() {
		int num = 4;
		GroupPermutation SGroup = new GroupPermutation(num);
		GroupPermutation.Bijection[] funElements = SGroup.getElements();
		
		for (int i = 0; i < funElements.length; i++) {
			GroupPermutation.Bijection function = funElements[i];
			GroupPermutation.Permutation permutation = GroupPermutation.Permutation.getCycleList(function);
			System.out.println("Function " + function.getName() + ": " + function.toPermString() + " = " + permutation.toCycleString() + " = " + permutation.toTranspositionString());
		}
		
		GroupPermutation.Bijection[] S3Elements = new GroupPermutation.Bijection[6];
		S3Elements[0] = funElements[0];
		S3Elements[1] = funElements[2];
		S3Elements[2] = funElements[6];
		S3Elements[3] = funElements[8];
		S3Elements[4] = funElements[12];
		S3Elements[5] = funElements[14];
		
		GroupPermutation.Bijection[] KElements = new GroupPermutation.Bijection[4];
		KElements[0] = funElements[0];
		KElements[1] = funElements[7];
		KElements[2] = funElements[16];
		KElements[3] = funElements[23];

		System.out.println("S3 * K");
		for (int i = 0; i < S3Elements.length; i++) {
			GroupPermutation.Permutation S3Permutation = GroupPermutation.Permutation.getCycleList(S3Elements[i]);
			for (int j = 0; j < KElements.length; j++) {
				GroupPermutation.Permutation KPermutation = GroupPermutation.Permutation.getCycleList(KElements[j]);
				GroupPermutation.Bijection value = S3Elements[i].composite(KElements[j]);
				boolean found = false;
				for (int k = 0; k < funElements.length; k++) {
					if (value.equals(funElements[k])) {
						GroupPermutation.Permutation resPermutation = GroupPermutation.Permutation.getCycleList(funElements[k]);
						
						System.out.println(S3Elements[i].getName() + "=" + S3Permutation.toCycleString() + " * " + KElements[j].getName() + "=" + KPermutation.toCycleString() + " = " + 
								funElements[k].getName() + "=" + resPermutation.toCycleString());
						found = true;
						break;
					} 
				}
				if (found == false) {
					System.out.println("Can not find: " + value.toPermString());
				}
			}
		}

		System.out.println("K * S3");
		for (int i = 0; i < S3Elements.length; i++) {
			GroupPermutation.Permutation S3Permutation = GroupPermutation.Permutation.getCycleList(S3Elements[i]);
			for (int j = 0; j < KElements.length; j++) {
				GroupPermutation.Permutation KPermutation = GroupPermutation.Permutation.getCycleList(KElements[j]);
				GroupPermutation.Bijection value = KElements[j].composite(S3Elements[i]);
				boolean found = false;
				for (int k = 0; k < funElements.length; k++) {
					if (value.equals(funElements[k])) {
						GroupPermutation.Permutation resPermutation = GroupPermutation.Permutation.getCycleList(funElements[k]);
						
						System.out.println(KElements[j].getName() + "=" + S3Permutation.toCycleString() + " * " + S3Elements[i].getName() + "=" + KPermutation.toCycleString() + " = " + 
								funElements[k].getName() + "=" + resPermutation.toCycleString());
						found = true;
						break;
					} 
				}
				if (found == false) {
					System.out.println("Can not find: " + value.toPermString());
				}
			}
		}
		
//		char[] values = {'7', '3', '6', '2', '5', '4', '1'};
//		GroupPermutation.Function function = new GroupPermutation.Function("f1", values);
//		System.out.println("Before getCycleList()...!");
//		GroupPermutation.Permutation permutation = GroupPermutation.Permutation.getCycleList(function);
//		System.out.println("After getCycleList()...!");
//		String permString = function.toPermString();
//		String cycleString = permutation.toCycleString();
//		String transString = permutation.toTranspositionString();
//		System.out.println("Function " + function.getName() + ": " + permString + " = " + cycleString + " = " + transString);
	}
	
	public static void testGaussIntegerDomainProduct() {
		int m = 17;
		
		int zeroCounter = 0;
		
		for (int a = 0; a < m; a++) {
			for (int b = 0; b < m; b++) {
				if (a==0 && b == 0) continue;
				
				for (int c = 0; c < m; c++) {
					for (int d = 0; d < m; d++) {
						if (c == 0 && d == 0) continue;
						
						int real = (a*c-b*d) % m;
						int image = (a*d + b*c) % m;
						
						if (real == 0 && image == 0) {
							zeroCounter++;
							System.out.println("(" + a + "+" + b + "i)*(" + c + "+" + d + "i) = 0, find zero divisor " + zeroCounter + "!");
						} else {
							System.out.println("(" + a + "+" + b + "i)*(" + c + "+" + d + "i) = (" + real + "+" + image + "i)!");
						}
					}
				}
			}
		}
		System.out.println("There are " + zeroCounter + " zero divisors!");
	}

	public static void testGaussComplex1() {
		GaussComplex x = new GaussComplex(2, -3);
		GaussComplex y = new GaussComplex(4, 7);
//		GaussComplex z = new GaussComplex(0, 9);
		
		System.out.println("x = " + x + ", y = " + y);
//		System.out.println("x * y = " + x.times(y));
		
		GaussComplex q = y.div(x); 
		GaussComplex r = y.mod(x);
		System.out.println(y + " = " + "(" + x + ")*(" + q + ") + (" + r + ") = (" + x.times(q) + ") + (" + r + ")");
		
//		GuassComplex t = x.times(q).add(r);
//		System.out.println("t = x*q+r = " + t);

//		q = z.div(x); 
//		r = z.mod(x);
//		System.out.println("z / x = " + q + ", z % x = " + r);
		
//		t = x.times(q).add(r);
//		System.out.println("t = x*q+r = " + t);
	}

	public static int findAllRemainder(GaussComplex d, GaussComplex remain[]) {
		int a = d.getReal(), b = d.getImage();
		
		if (a == 0 && b == 0) return 0;
		
		int n = a*a+b*b;
		int m = (b == 0) ? a : b;
		if (m < 0) m = -m;

		int printNumber = 0;
		int totalNumber = n * m;
//		System.out.println("\\begin{align*}");
		int count = 0;
		for (int x = 0; x < n; x++) {
			for (int y = 0; y < m; y++) {
				GaussComplex s = new GaussComplex(x, y);
				
				GaussComplex q = s.div(d);
				GaussComplex r = s.mod(d);
				
//				System.out.print("\\textrm{" + s + "}~=&~" + "(\\textrm{" + q + "})*(\\textrm{" + d + "})+(\\textrm{"+r+"}) & ");
				printNumber++;
				if (printNumber % 3 == 0 && totalNumber > printNumber) {
//					System.out.println("\\\\");
				}
				
				boolean found = false;
				int index = count;
				for (int i = 0; i < count; i++) {
					int diff = r.compare(remain[i]);
					if (diff == 0) {
						found = true;
						break;
					}
					if (diff < 0) {
						index = i;
						break;	
					}
				}
				if (found == false) {
					for (int i = count; i>index; i--) remain[i] = remain[i-1];
					remain[index] = r;
					count++;
				}
			}
		}
//		System.out.println();
//		System.out.println("\\end{align*}");
		return count;
	}
	
	public static int findIdentityIndex(GaussComplex d, GaussComplex[] remain, int count) {
		int resultIndex = -1;
		boolean found = false;
		for (int i = 0; i < count; i++) {
			GaussComplex check = remain[i];
			if (check.isZero()) continue;
			boolean isNotIdentity = false;
			for (int j = 0; j < count; j++) {
				if (remain[j].isZero()) continue;
				
				GaussComplex result = check.times(remain[j]).mod(d);
				if (!result.equals(remain[j])) {
					isNotIdentity = true;
					break;
				}
			}
			if (!isNotIdentity) {
				if (found == true) {
					System.out.println("Has found an identity: " + remain[resultIndex] + ", and also found another identity: " + check);
				} else {
					resultIndex = i;
					found = true;
				}
			}
		}
		return resultIndex;
	}
	
	public static boolean checkAllRemainder(GaussComplex d, GaussComplex[] remain, int count) {
		int a = d.getReal();
		int b = d.getImage();
		boolean[] foundRemain = new boolean[count];
		
		if (a == 0 && b == 0) return false;
		int n = (a == 0) ? b : a;
		int m = (b == 0) ? a : b;
		if (n < 0) n = -n;
		if (m < 0) m = -m;

		System.out.println("检查余数: a = " + a + ", b = " + b + ", n = " + n + ", m = " + m + "\\\\");
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				GaussComplex check = new GaussComplex(i, j);
				boolean found = false;
				for (int k = 0; k < count; k++) {
					if (check.equals(remain[k])) {
						foundRemain[k] = true;
						found = true;
						break;
					}
				}
				if (found == false) {
					GaussComplex r = check.mod(d);
					GaussComplex q = check.div(d);
					System.out.println("\t余数中没有发现: " + check + " = (" + q + ") * (" + d + ") + " + r + "\\\\");
				}
				if (i == 0 && j == 0) continue;
				
				if (i != 0) {
					check = new GaussComplex(-i, j);
					found = false;
					for (int k = 0; k < count; k++) {
						if (check.equals(remain[k])) {
							foundRemain[k] = true;
							found = true;
							break;
						}
					}
					if (found == false) {
						GaussComplex r = check.mod(d);
						GaussComplex q = check.div(d);
						System.out.println("\t余数中没有发现: " + check + " = (" + q + ") * (" + d + ") + " + r + "\\\\");
					}
				}

				if (j != 0) {
					check = new GaussComplex(i, -j);
					found = false;
					for (int k = 0; k < count; k++) {
						if (check.equals(remain[k])) {
							foundRemain[k] = true;
							found = true;
							break;
						}
					}
					if (found == false) {
						GaussComplex r = check.mod(d);
						GaussComplex q = check.div(d);
						System.out.println("\t余数中没有发现: " + check + " = (" + q + ") * (" + d + ") + " + r + "\\\\");
					}
				}

				if (i != 0 && j != 0) {
					check = new GaussComplex(-i, -j);
					found = false;
					for (int k = 0; k < count; k++) {
						if (check.equals(remain[k])) {
							foundRemain[k] = true;
							found = true;
							break;
						}
					}
					if (found == false) {
						GaussComplex r = check.mod(d);
						GaussComplex q = check.div(d);
						System.out.println("\t余数中没有发现: " + check + " = (" + q + ") * (" + d + ") + " + r + "\\\\");
					}
				}
			}
		}
		
		for (int k = 0; k < count; k++) {
			if (foundRemain[k] == false) {
				System.out.println("\t给定范围中没有出现的余数: " + remain[k] + "\\\\");
			}
		}
		return true;
	}
	
	public static FiniteRing<GaussComplex> createGaussDomain(GaussComplex d, GaussComplex[] remain, int count) {
		GaussComplex zero = new GaussComplex(0, 0);
		
		int zeroIndex = -1;
		GaussComplex[] base = new GaussComplex[count];
		for (int i = 0; i < count; i++) {
			if (remain[i].equals(zero)) zeroIndex = i;
			base[i] = remain[i];
		}
		int identityIndex = findIdentityIndex(d, remain, count);

		GaussComplex[][] plusOptable = new GaussComplex[base.length][base.length];
		
		for (int i = 0; i < base.length; i++) {
			for (int j = 0; j < base.length; j++) {
				plusOptable[i][j] = base[i].add(base[j]).mod(d);
			}
		}
		BinaryOperator<GaussComplex> plus = new BinaryOperator<GaussComplex>(base, plusOptable);
		plus.setName("+");
		
		GaussComplex[][] timesOptable = new GaussComplex[base.length][base.length];
		
		for (int i = 0; i < base.length; i++) {
			for (int j = 0; j < base.length; j++) {
				timesOptable[i][j] = base[i].times(base[j]).mod(d);
			}
		}
		BinaryOperator<GaussComplex> times = new BinaryOperator<GaussComplex>(base, timesOptable);
		times.setName("*");

		return new FiniteRing<GaussComplex>(base, plus, times, zeroIndex, identityIndex);
	}
	
	public static void demoGaussComplexDomain(FiniteRing<GaussComplex> gaussDomain) {
//		System.out.println("\\begin{center}");
//		System.out.println(gaussDomain.getPlusTableLaTexString());
//		System.out.println("\\end{center}");

//		System.out.println("\\begin{center}");
//		System.out.println(gaussDomain.getTimesTableLaTexString());
//		System.out.println("\\end{center}");
		
		List<GaussComplex> zeroFactorList = gaussDomain.getZeroFactorList();
		if (zeroFactorList.size() > 0) {
			System.out.println("\\qquad 零因子： \\\\");
			for (int i = 0; i < zeroFactorList.size(); i+=2)	System.out.println("\t" + zeroFactorList.get(i) + " \\quad " + zeroFactorList.get(i+1) + " \\\\");
		}

		List<GaussComplex> unitList = gaussDomain.getUnitList();
		if (zeroFactorList.size() > 0) {
			System.out.println("\\qquad 单位： \\\\");
			for (int i = 0; i < unitList.size(); i++)	System.out.println("\t" + unitList.get(i) + " \\\\");
		}
		
		if (gaussDomain.isField()) {
			GaussComplex[] base = gaussDomain.getElements();
			System.out.println("它是域，每个元素的乘法阶如下：\\\\");
			for (int i = 0; i < base.length; i++) {
				if (base[i].isZero()) continue;
				int order = gaussDomain.getTimesOrder(base[i]);

				if (order > 1) {
					GaussComplex inverse = gaussDomain.getInverseElement(base[i]);
					System.out.println("\t$" + base[i].toLaTexString() + "$的阶： $" + order + "$, 逆是：$" + inverse.toLaTexString() + "$");
					System.out.println("\\begin{align*}");
					GaussComplex result = base[i];
					for (int j = 2; j <= order; j++) {
						result = gaussDomain.getTimesResult(result, base[i]);
						System.out.print("(" + base[i].toLaTexString() + ")^{" + j + "} ~=&~ " + result.toLaTexString() + " & ");
						if (j % 7 == 0 && order > j) System.out.println(" \\\\");
					}
					System.out.println();
					System.out.println("\\end{align*}");
				} else {
					System.out.println("\t$" + base[i].toLaTexString() + "$的阶： $" + order + "$ \\\\");
				}
			}
		} else {
			System.out.println("它不是域！");
			if (!gaussDomain.hasIdentity()) System.out.println("它没有单位元！");
			if (!gaussDomain.isCommutative()) System.out.println("它不是交换环！");
			if (gaussDomain.hasZeroFactor()) System.out.println("它有零因子！");
		}
	}
	
	public static void testGaussComplex() {
		int a = 3, b = 7;
		GaussComplex d = new GaussComplex(a, b);
		GaussComplex[] remain = new GaussComplex[100];
		System.out.println("寻找$\\mathbb{Z}[\\textrm{i}]/\\langle " + d.toLaTexString() + "\\rangle$中的可能元素：");
		int count = findAllRemainder(d, remain);
		
		System.out.println("最终得到$\\mathbb{Z}[\\textrm{i}]/\\langle " + d.toLaTexString() + "\\rangle$的所有元素：");
		System.out.println("\\begin{align*}");
		for (int i = 0; i < count; i++) {
			System.out.println(i + "~:&\\qquad\\textrm{" + remain[i] + "} & \\textrm{范数}~=&~" + remain[i].normal() + " \\\\");
		}
		System.out.println("\\end{align*}");
		
		checkAllRemainder(d, remain, count);
		
		FiniteRing<GaussComplex> gaussDomain = createGaussDomain(d, remain, count);
		demoGaussComplexDomain(gaussDomain);
		System.out.println("\\clearpage");
	}

	public static void testSVModPoly1() {
		int m = 3;
		int[] modPolyCoeff = {1, 1, 2};
		SVModPoly[] polys = createAllModPoly(m, modPolyCoeff.length-2);
		SVModPoly modPoly = new SVModPoly(m, modPolyCoeff);
		
		for (int i = 0; i < polys.length; i++) {
			System.out.println(polys[i]);
		}
		
//		int i = 2, j = 2;
//		SVModPoly result = polys[i].times(polys[j]);
//		System.out.println(polys[i] + " * " + polys[j] + " = " + result + ", result.size = " + result.coeff.size());

//		result = result.mod(modPoly);
//		System.out.println(" and mod " + modPoly + " = " + result + ", result.size = " + result.coeff.size());
		
		BinaryOperator<SVModPoly> table = createTimesTable(polys, modPoly);
		table.setName("$\\otimes_"+m+"$");
		System.out.println("Times table: $Z[" + m + "]$, mod " + modPoly);
		System.out.println(table.toLaTeXString());
		
		if (table.hasIdentity()) System.out.println("Operator has identity!");
		else System.out.println("Operator has NOT identity!");
		
		if (table.hasInverse()) System.out.println("Operator has inverse!");
		else {
			String message = BinaryOperator.getReasonMessage();
			System.out.println("Operator has NOT inverse: " + message);
		}

		if (table.isCommutative()) System.out.println("Operator is commutative!");
		else {
			String message = BinaryOperator.getReasonMessage();
			System.out.println("Operator is NOT commutative: " + message);
		}
		
		if (table.isAssociative()) System.out.println("Operator is associative!");
		else {
			String message = BinaryOperator.getReasonMessage();
			System.out.println("Operator is NOT associative: " + message);
		}
		
		table = removeZeroFactor(table, modPoly);
		table.setName("$\\otimes_"+m+"$");
		System.out.println("New operator table: $Z[" + m + "]$, mod " + modPoly);
		System.out.println(table.toLaTeXString());
		
		if (table.hasIdentity()) System.out.println("Operator has identity!");
		else System.out.println("Operator has NOT identity!");
		
		if (table.hasInverse()) System.out.println("Operator has inverse!");
		else {
			String message = BinaryOperator.getReasonMessage();
			System.out.println("Operator has NOT inverse: " + message);
		}

		if (table.isCommutative()) System.out.println("Operator is commutative!");
		else {
			String message = BinaryOperator.getReasonMessage();
			System.out.println("Operator is NOT commutative: " + message);
		}
		
		if (table.isAssociative()) System.out.println("Operator is associative!");
		else {
			String message = BinaryOperator.getReasonMessage();
			System.out.println("Operator is NOT associative: " + message);
		}
	}
	
	private static BinaryOperator<SVModPoly> removeZeroFactor(BinaryOperator<SVModPoly> table, SVModPoly modPoly) {
		SVModPoly[] oldbase = table.getBase();
		boolean[] flag = new boolean[oldbase.length];
		int size = 0;
		for (int i = 0; i < oldbase.length; i++) {
			if (oldbase[i].isUnit()) {
				flag[i] = true;  size++;
			} else if (!oldbase[i].isZero() && !oldbase[i].isFactor(modPoly)) {
				flag[i] = true;
				size++;
			} else flag[i] = false;
		}
		SVModPoly[] nbase = new SVModPoly[size];
		int index = 0;
		for (int i = 0; i < oldbase.length; i++) {
			if (flag[i]) {
				nbase[index] = oldbase[i];
				index++;
			}
		}
		
		SVModPoly[][] result = new SVModPoly[size][size];
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				result[i][j] = table.getOperationResult(nbase[i], nbase[j]);
			}
		}
		
		return new BinaryOperator<SVModPoly>(nbase, result);
	}
	
	
	private static BinaryOperator<SVModPoly> createTimesTable(SVModPoly[] base, SVModPoly modPoly) {
		int[][] table = new int[base.length][base.length];
		
		for (int i = 0; i < base.length; i++) {
			for (int j = 0; j < base.length; j++) {
				SVModPoly resultPoly = base[i].times(base[j]);
//				System.out.println("times: " + resultPoly + " = " + base[i] + " * " + base[j]);
				resultPoly = resultPoly.mod(modPoly);
//				System.out.println("mod: " + resultPoly + " % " + modPoly);
				
				boolean found = false;
				for (int index = 0; index < base.length; index++) {
					if (base[index].equals(resultPoly)) {
						table[i][j] = index;
						found = true;
						break;
					}
				}
				if (!found) {
					System.out.println("Has not found result: " + resultPoly + " = " + base[i] + " * " + base[j]);
				}
			}
		}
		BinaryOperator<SVModPoly> result = new BinaryOperator<SVModPoly>(base, table);
		return result;
	}

	private static BinaryOperator<SVModPoly> createPlusTable(SVModPoly[] base, SVModPoly modPoly) {
		int[][] table = new int[base.length][base.length];
		
		for (int i = 0; i < base.length; i++) {
			for (int j = 0; j < base.length; j++) {
				SVModPoly resultPoly = base[i].add(base[j]);
//				System.out.println("times: " + resultPoly + " = " + base[i] + " * " + base[j]);
				resultPoly = resultPoly.mod(modPoly);
//				System.out.println("mod: " + resultPoly + " % " + modPoly);
				
				boolean found = false;
				for (int index = 0; index < base.length; index++) {
					if (base[index].equals(resultPoly)) {
						table[i][j] = index;
						found = true;
						break;
					}
				}
				if (!found) {
					System.out.println("Has not found result: " + resultPoly + " = " + base[i] + " * " + base[j]);
				}
			}
		}
		BinaryOperator<SVModPoly> result = new BinaryOperator<SVModPoly>(base, table);
		return result;
	}
	
	private static SVModPoly[] createAllModPoly(int m, int highestPower) {
		int resultPolyNumber = 1;
		for (int i = 0; i <= highestPower; i++) resultPolyNumber = resultPolyNumber * m;
		int[] coeffArray = new int[highestPower+1];
		for (int i = 0; i < coeffArray.length; i++) coeffArray[i] = 0;
		coeffArray[coeffArray.length-1] = 1;
		
		SVModPoly[] resultPolyArray = new SVModPoly[resultPolyNumber];
		resultPolyArray[0] = new SVModPoly(m, 0);
		int resultIndex = 1;
		while (true) {
			int firstNonZeroIndex = 0;
			while (coeffArray[firstNonZeroIndex] == 0) firstNonZeroIndex++;
			
			int[] currentCoeff = new int[coeffArray.length-firstNonZeroIndex];
			for (int i = 0; i < currentCoeff.length; i++) currentCoeff[i] = coeffArray[firstNonZeroIndex+i];
			resultPolyArray[resultIndex] = new SVModPoly(m, currentCoeff);
			resultIndex = resultIndex + 1;
			
			boolean isLast = true;
			for (int i = coeffArray.length-1; i >= 0; i--) {
				if (coeffArray[i] == (m-1)) coeffArray[i] = 0;
				else {
					coeffArray[i] += 1;
					isLast = false;
					break;
				}
			}
			if (isLast) break;
		}
		
		return resultPolyArray;
	}

	public static FiniteRing<SVModPoly> createSVModPolyRing(int m, SVModPoly modPoly) {
		int hightest = modPoly.getMostPower()-2;
		SVModPoly[] base = createAllModPoly(m, hightest);

		System.out.println("$\\mathbb{Z}[" + modPoly.getVariable() + "]/\\langle " + modPoly.toPlainString() + " \\rangle$的所有元素：");
		System.out.println("\\begin{align*}");
		for (int i = 0; i < base.length; i++) {
			System.out.println(i + "~:&\\qquad " + base[i].toPlainString() + " \\\\");
		}
		System.out.println("\\end{align*}");

		
		int zeroIndex = -1;
		int identityIndex = -1;
		for (int i = 0; i < base.length; i++) {
			if (base[i].isZero()) zeroIndex = i;
			if (base[i].isUnit()) identityIndex = i;
		}
		
		BinaryOperator<SVModPoly> plus = createPlusTable(base, modPoly);
		plus.setName("$\\oplus_{" + m + "}$");
		BinaryOperator<SVModPoly> times = createTimesTable(base, modPoly);
		times.setName("$\\otimes_{" + m + "}$");
		
		FiniteRing<SVModPoly> ring = new FiniteRing<SVModPoly>(base, plus, times, zeroIndex, identityIndex);
		return ring;
	}
	
	
	public static void demoSVModPolyRing(FiniteRing<SVModPoly> svmodRing) {
		System.out.println("\\begin{center}");
		System.out.println(svmodRing.getPlusTableLaTexString());
		System.out.println("\\end{center}");

		System.out.println("\\begin{center}");
		System.out.println(svmodRing.getTimesTableLaTexString());
		System.out.println("\\end{center}");
		
		List<SVModPoly> zeroFactorList = svmodRing.getZeroFactorList();
		if (zeroFactorList.size() > 0) {
			System.out.println("\\qquad 零因子： \\\\");
			for (int i = 0; i < zeroFactorList.size(); i+=2) System.out.println("\t" + zeroFactorList.get(i) + " \\quad " + zeroFactorList.get(i+1) + " \\\\");
		}

		List<SVModPoly> unitList = svmodRing.getUnitList();
		if (zeroFactorList.size() > 0) {
			System.out.println("\\qquad 单位： \\\\");
			for (int i = 0; i < unitList.size(); i++) System.out.println("\t" + unitList.get(i) + " \\\\");
		}
		
		if (svmodRing.isField()) {
			SVModPoly[] base = svmodRing.getElements();
			System.out.println("它是域，每个元素的乘法阶如下：\\\\");
			for (int i = 0; i < base.length; i++) {
				if (base[i].isZero()) continue;
				int order = svmodRing.getTimesOrder(base[i]);

				if (order > 1) {
					SVModPoly inverse = svmodRing.getInverseElement(base[i]);
					System.out.println("\t" + base[i] + " 的阶： $" + order + "$, 逆是： " + inverse);
					System.out.println("\\begin{align*}");
					SVModPoly result = base[i];
					for (int j = 2; j <= order; j++) {
						result = svmodRing.getTimesResult(result, base[i]);
						System.out.print("(" + base[i].toPlainString() + ")^{" + j + "} ~=&~ " + result.toPlainString() + " & ");
						if (j % 6 == 0 && order > j) System.out.println(" \\\\");
					}
					System.out.println();
					System.out.println("\\end{align*}");
				} else {
					System.out.println("\t" + base[i] + " 的阶： $" + order + "$ \\\\");
				}
			}
		} else {
			System.out.println("它不是域！");
			if (!svmodRing.hasIdentity()) System.out.println("它没有单位元！");
			if (!svmodRing.isCommutative()) System.out.println("它不是交换环！");
			if (svmodRing.hasZeroFactor()) System.out.println("它有零因子！");
		}
	}
	
	public static void testSVModPolyRing() {
		int m = 2;
		int[] modPolyCoeff = {1, 1, 1, 1, 1};
		SVModPoly modPoly = new SVModPoly(m, modPolyCoeff);
		
		FiniteRing<SVModPoly> ring = createSVModPolyRing(m, modPoly);
		demoSVModPolyRing(ring);
		System.out.println("\\clearpage");
	}
	
	public static void main(String[] args) {
//		testSVModPolyRing();		
		testGaussComplex1();
//		testPermutation();
		
//		testGroupUnitModulo();
//		testGroupPermutation();
//		testSubgroup();
//		testPermutationNormalSubgroup();
//		testLattice();
	}
	
}
